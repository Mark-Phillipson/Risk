@page "/map"
@using WorldConquestGame.Client.Pages
@inject IJSRuntime JS
@inject WorldConquestGame.Client.Services.GameService GameService
@inject WorldConquestGame.Client.Services.StorageService StorageService

<div class="map-page">
    <div id="map" class="map"></div>
    <div class="sidebar-container">
        <div class="sidebar-panel" style="width:@(ShowCountries ? "320px" : "36px");">
            <div class="sidebar-content">
                <div class="sidebar-header">
                        <div class="sidebar-controls">
                            @* Refresh button — only visible when the countries panel is expanded *@
                            @if (ShowCountries)
                            {
                                <button class="btn btn-sm geo-sidebar-btn" title="Refresh countries" @onclick="RefreshCountries">
                                    <i class="bi bi-arrow-clockwise"></i>
                                </button>
                            }

                            @* Show filter buttons only when the countries panel is expanded *@
                            @if (ShowCountries)
                            {
                                <div class="btn-group filter-group" role="group">
                                    <button class="btn btn-sm geo-filter-btn @GetActiveAll()" @onclick="SetCountriesFilterAll">All</button>
                                    <button class="btn btn-sm geo-filter-btn @GetActiveGuessed()" @onclick="SetCountriesFilterGuessed">Guessed</button>
                                    <button class="btn btn-sm geo-filter-btn @GetActiveUnguessed()" @onclick="SetCountriesFilterUnguessed">Unguessed</button>
                                </div>
                            }
                        </div>
                </div>

                <div class="sidebar-body">
                    @if (ShowCountries)
                    {
                        <Countries @ref="CountriesRef" Title="Countries" />
                    }
                </div>
            </div>
        </div>
    </div>
    <!-- Reset button removed from map overlay to avoid covering map controls -->
        <!-- Floating bottom-left toggle so it doesn't collide with top-left zoom controls -->
        <button class="floating-toggle" title="Toggle countries panel" @onclick="() => ShowCountries = !ShowCountries">
            @if (ShowCountries)
            {
                <i class="bi bi-chevron-left"></i>
            }
            else
            {
                <i class="bi bi-list"></i>
            }
        </button>

    <!-- Render QuestionPanel locally on the map page for visibility -->
    <QuestionPanel />
</div>

@code {
    private DotNetObjectReference<Map>? objRef;
    private bool ShowCountries = false;
    private Countries? CountriesRef;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            objRef = DotNetObjectReference.Create(this);
            // Disable persistent country labels on this map page; rely on color only.
            try { await JS.InvokeVoidAsync("sessionStorage.setItem", "showCountryLabels", "false"); } catch { }
            await JS.InvokeVoidAsync("mapInterop.initMap", "map", "data/countries.geojson", objRef);

            // After map loads, attempt to read persisted countries and re-apply styles
            // We wait briefly to allow the geo layer to fully register layers and centroids in JS
            try
            {
                // Check if a reset was requested from the layout (sessionStorage.resetMap)
                try
                {
                    var resetReq = await JS.InvokeAsync<string>("sessionStorage.getItem", "resetMap");
                    if (!string.IsNullOrEmpty(resetReq))
                    {
                        // clear the flag and perform reset actions
                        await JS.InvokeVoidAsync("sessionStorage.removeItem", "resetMap");
                        await JS.InvokeVoidAsync("mapInterop.clearConquered");
                        try { await StorageService.ClearCountriesAsync(); } catch { }
                    }
                }
                catch { }

                var persisted = await StorageService.LoadCountriesAsync();
                // log what we loaded for debugging
                await JS.InvokeVoidAsync("console.log", "Map: loaded persisted countries:", persisted == null ? 0 : persisted.Count,
                persisted);
                if (persisted != null && persisted.Count > 0)
                {
                    // merge into in-memory model
                    GameService.MergePersistedCountries(persisted);

                    // For debugging: build detailed lists of ids and colors we'll send to JS
                    var ids = new List<string>();
                    var colors = new List<string>();
                    foreach (var c in persisted.Where(p => p.IsConquered && !string.IsNullOrEmpty(p.Code)))
                    {
                        ids.Add(c.Code!);
                        colors.Add(string.IsNullOrEmpty(c.Color) ? "#ffcc00" : c.Color!);
                    }

                    // Log the exact payload we will send to mapInterop
                    await JS.InvokeVoidAsync("console.log", "Map: restoring conquered countries, ids:", ids, "colors:", colors);

                    if (ids.Count > 0)
                    {
                        // call JS to apply styles for multiple countries — pass per-id colors array
                        var result = await JS.InvokeAsync<object?>("mapInterop.setCountryConqueredAny", ids.ToArray(), colors.ToArray());
                        await JS.InvokeVoidAsync("console.log", "Map: mapInterop.setCountryConqueredAny returned:", result);
                    }
                }
            }
            catch (Exception ex)
            {
                await JS.InvokeVoidAsync("console.error", "Map: failed to restore persisted countries", ex.Message);
            }
        }
    }

    [JSInvokable]
    public async Task OnCountryClicked(string id)
    {
        // id will be code or name from GeoJSON properties
        Console.WriteLine($"Map.OnCountryClicked called with id={id}");
        await JS.InvokeVoidAsync("console.log", $"[Blazor] OnCountryClicked called with id={id}");
        // Log all countries for debugging
        foreach (var c in GameService.Countries)
        {
            await JS.InvokeVoidAsync("console.log", $"[Blazor] Country: Code={c.Code}, Name={c.Name}, IsConquered={c.IsConquered}");
        }
        var country = GameService.Countries.FirstOrDefault(c => c.Code == id || c.Name == id);
        if (country == null)
        {
            await JS.InvokeVoidAsync("console.warn", $"[Blazor] No country found for id={id}");
        }
        else
        {
            await JS.InvokeVoidAsync("console.log", $"[Blazor] Found country: Code={country.Code}, Name={country.Name}, IsConquered={country.IsConquered}");
            if (country.IsConquered)
            {
                string wikiTarget = country.Name;
                if (string.IsNullOrWhiteSpace(wikiTarget))
                {
                    // Fallback: use code, and for common codes, map to Wikipedia-friendly names
                    wikiTarget = country.Code switch
                    {
                        "GBR" => "United Kingdom",
                        "USA" => "United States",
                        "CAN" => "Canada",
                        "AUS" => "Australia",
                        "NZL" => "New Zealand",
                        "GRL" => "Greenland",
                        _ => country.Code
                    };
                }
                await JS.InvokeVoidAsync("console.log", $"[Blazor] Opening Wikipedia for {wikiTarget}");
                await JS.InvokeVoidAsync("mapInterop.openWikipediaTab", wikiTarget);
            }
        }
        GameService.RaiseCountryClicked(id);
    }

    private async Task ResetMap()
    {
        try
        {
            // Clear JS map visual state
            await JS.InvokeVoidAsync("mapInterop.clearConquered");
        }
        catch { }

        try
        {
            // Clear persisted storage
            await StorageService.ClearCountriesAsync();
        }
        catch { }

        // Optionally reload the page to reinitialize map cleanly
        try { await JS.InvokeVoidAsync("location.reload"); } catch { }
    }


    public void Dispose()
    {
        objRef?.Dispose();
    }

    private void SetCountriesFilter(string name)
    {
        try
        {
            CountriesRef?.SetFilterByName(name);
            // trigger UI refresh to update active button state
            InvokeAsync(StateHasChanged);
        }
        catch { }
    }

    // Parameterless helpers used from Razor to avoid quoting issues
    private void SetCountriesFilterAll() => SetCountriesFilter("All");
    private void SetCountriesFilterGuessed() => SetCountriesFilter("Guessed");
    private void SetCountriesFilterUnguessed() => SetCountriesFilter("Unguessed");

    private string GetActiveAll() => CountriesRef != null && CountriesRef.GetCurrentFilterName() == "All" ? "active" : string.Empty;
    private string GetActiveGuessed() => CountriesRef != null && CountriesRef.GetCurrentFilterName() == "Guessed" ? "active" : string.Empty;
    private string GetActiveUnguessed() => CountriesRef != null && CountriesRef.GetCurrentFilterName() == "Unguessed" ? "active" : string.Empty;

    private async Task RefreshCountries()
    {
        try
        {
            if (CountriesRef != null)
            {
                await CountriesRef.RefreshListAsync();
                await InvokeAsync(StateHasChanged);
            }
        }
        catch { }
    }
}